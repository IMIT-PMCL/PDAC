import argparse
from pathlib import Path
import numpy as np
import nibabel as nib
import matplotlib
matplotlib.use("Agg")  # headless-safe
import matplotlib.pyplot as plt
from scipy.ndimage import map_coordinates, label, center_of_mass
from scipy.spatial.distance import euclidean
from math import acos, degrees

def load_nifti(file_path):
    nifti = nib.load(str(file_path))
    data = nifti.get_fdata()
    return data, nifti.affine, nifti.header

def extract_coordinates(mask_data):
    return np.argwhere(mask_data)

def calculate_tangent_vectors(coords):
    tangents = np.diff(coords, axis=0)
    tangents = np.vstack((tangents, tangents[-1]))
    return tangents

def normalize(vectors):
    norms = np.linalg.norm(vectors, axis=1, keepdims=True)
    norms[norms == 0] = 1
    return vectors / norms

def find_plane_vectors(tangent):
    if np.all(tangent[:2] == 0):
        perp_vector = np.array([1, 0, 0])
    else:
        perp_vector = np.array([0, 0, 1])
    normal = np.cross(tangent, perp_vector)
    binormal = np.cross(tangent, normal)
    normal = normalize(normal.reshape(1, -1)).flatten()
    binormal = normalize(binormal.reshape(1, -1)).flatten()
    return normal, binormal

def generate_slice_coords(point, tangent, normal, binormal, size=256, spacing=1.0):
    half = size // 2
    grid_x, grid_y = np.meshgrid(np.arange(-half, half) * spacing,
                                 np.arange(-half, half) * spacing)
    grid_x = grid_x.flatten()
    grid_y = grid_y.flatten()
    plane_coords = (point[:, np.newaxis] +
                    grid_x * normal[:, np.newaxis] +
                    grid_y * binormal[:, np.newaxis])
    return plane_coords

def reslice_image(data, slice_coords):
    return map_coordinates(data, [slice_coords[0], slice_coords[1], slice_coords[2]], order=1)

def find_boundary_points(region_mask, tumor_mask):
    boundary_points = []
    for x in range(1, region_mask.shape[0] - 1):
        for y in range(1, region_mask.shape[1] - 1):
            if region_mask[x, y] > 0 and tumor_mask[x, y] > 0:
                neighbors = region_mask[x-1:x+2, y-1:y+2]
                if np.any(neighbors == 0):
                    boundary_points.append((x, y))
    return boundary_points

def calculate_wrap_angle(region_mask, tumor_mask):
    boundary_points = find_boundary_points(region_mask, tumor_mask)
    if len(boundary_points) < 2:
        return None
    point_b, point_c = boundary_points[0], boundary_points[-1]
    centroid = center_of_mass(region_mask)
    distance_ab = euclidean(centroid, point_b)
    distance_ac = euclidean(centroid, point_c)
    distance_bc = euclidean(point_b, point_c)
    cos_val = (distance_ab**2 + distance_ac**2 - distance_bc**2) / (2 * distance_ab * distance_ac + 1e-8)
    cos_val = np.clip(cos_val, -1.0, 1.0)
    raw_angle_bac = degrees(acos(cos_val))
    centroid_in_intersection = tumor_mask[int(centroid[0]), int(centroid[1])] > 0
    wrap_angle = 360 - raw_angle_bac if centroid_in_intersection else raw_angle_bac
    return wrap_angle

def analyze_tumor_vessel_relationship(slice_vessel, slice_tumor, min_area_threshold=10, overlap_ratio_threshold=0.5):
    if np.sum(slice_vessel) == 0:
        return [("no_vessel_region", None, None)]
    if np.sum(slice_tumor) == 0:
        return [("no_tumor_region", None, None)]
    labeled_vessel, num_features = label(slice_vessel > 0)
    results = []
    for region in range(1, num_features + 1):
        region_mask = labeled_vessel == region
        relationship, wrap_angle = "no_contact", None
        region_area = np.sum(region_mask)
        if region_area < min_area_threshold:
            continue
        intersection = np.logical_and(region_mask, slice_tumor > 0)
        intersection_area = np.sum(intersection)
        if intersection_area == region_area:
            relationship = "complete_encasement"
        elif intersection_area > 0:
            if intersection_area > overlap_ratio_threshold * region_area:
                relationship = "partial_encasement"
                wrap_angle = calculate_wrap_angle(region_mask, slice_tumor)
            else:
                relationship = "minor_contact_no_encasement"
        results.append((region, relationship, wrap_angle))
    return results

def analyze_and_save(blood_vessel_path, tumor_path, centerline_path, out_dir,
                     size=256, spacing=1.0, min_area_threshold=10, overlap_ratio_threshold=0.5):
    out_dir = Path(out_dir); out_dir.mkdir(parents=True, exist_ok=True)
    blood_vessel_data, _, _ = load_nifti(blood_vessel_path)
    tumor_data, _, _ = load_nifti(tumor_path)
    centerline_data, _, _ = load_nifti(centerline_path)
    centerline_coords = extract_coordinates(centerline_data)
    tangents = calculate_tangent_vectors(centerline_coords)
    normalized_tangents = normalize(tangents)

    max_wrap_angle = 0.0
    for i in range(centerline_coords.shape[0]):
        point = centerline_coords[i]
        tangent = normalized_tangents[i]
        normal, binormal = find_plane_vectors(tangent)
        slice_coords = generate_slice_coords(point, tangent, normal, binormal, size=size, spacing=spacing)
        slice_coords = slice_coords.reshape(3, size, size)
        slice_2d_vessel = reslice_image(blood_vessel_data, slice_coords)
        slice_2d_tumor = reslice_image(tumor_data, slice_coords)
        relationships = analyze_tumor_vessel_relationship(slice_2d_vessel, slice_2d_tumor,
                                                           min_area_threshold, overlap_ratio_threshold)
        for region, relationship, wrap_angle in relationships:
            fig = plt.figure()
            plt.imshow(slice_2d_vessel, cmap="gray", alpha=0.7)
            plt.imshow(slice_2d_tumor, cmap="hot", alpha=0.3)
            title = f"centerline {i+1}, region {region}: {relationship}"
            if relationship == "partial_encasement" and wrap_angle is not None:
                title += f", angle: {wrap_angle:.2f}°"
                max_wrap_angle = max(max_wrap_angle, wrap_angle)
            plt.title(title)
            fig.savefig(out_dir / f"slice_{i+1:04d}_region_{region}.png", dpi=150, bbox_inches="tight")
            plt.close(fig)

    with open(out_dir / "summary.txt", "w") as f:
        f.write(f"max_wrap_angle_deg={max_wrap_angle:.2f}\n")
    print(f"[DONE] Saved figures and summary to: {out_dir}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Analyze tumor–vessel relationship from NIfTI masks.")
    parser.add_argument("--vessel", required=True, help="Path to vessel mask NIfTI")
    parser.add_argument("--tumor", required=True, help="Path to tumor mask NIfTI")
    parser.add_argument("--centerline", required=True, help="Path to centerline NIfTI")
    parser.add_argument("--out", default="./outputs", help="Output directory")
    parser.add_argument("--size", type=int, default=256)
    parser.add_argument("--spacing", type=float, default=1.0)
    parser.add_argument("--min-area", type=int, default=10)
    parser.add_argument("--overlap-ratio", type=float, default=0.5)
    args = parser.parse_args()

    analyze_and_save(
        blood_vessel_path=Path(args.vessel),
        tumor_path=Path(args.tumor),
        centerline_path=Path(args.centerline),
        out_dir=Path(args.out),
        size=args.size,
        spacing=args.spacing,
        min_area_threshold=args.min_area,
        overlap_ratio_threshold=args.overlap_ratio
    )